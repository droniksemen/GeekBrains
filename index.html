<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>DZ2</title>
	<link rel="stylesheet" href="style.css">
	<script src="jquery.js"></script>
	
</head>
<body>
	<!-- Задание 1 -->
	<div class="zd">
		<h3>Задание 1</h3>
		<p>var a = 1, b = 1, c, d;<br> c = ++a; alert(c); // 2 <br> d = b++; alert(d); // 1 <br>c = (2+ ++a); alert(c); // 5 <br>d = (2+ b++); alert(d); // 4 <br>alert(a); // 3 <br>alert(b); // 3
		</p>

		
		<div class="button" id="zd1Prim1">Проверка</div>
	</div>
	<!-- Задание 2 -->
	<div class="zd">
		<h3>Задание 2</h3>
		<p>Чему будет равен x в примере ниже?</p>
		<p><b>var a = 2;</b></p>
		<p>var x = 1 + (a *= 2);</p>
		<div class="button" id="zd2Otvet">Ответ</div>
		<div class="otv"></div>
	</div>
	<!-- Задание 3 -->
		<div class="zd">
			<h3>Задание 3</h3>
			<p>Объявить две целочисленные переменные a и b и задать им произвольные начальные значения. Затем написать скрипт, который работает по следующему принципу:
			</p>
		<p>* если a и b положительные,вывести их разность;<br> * если а и b отрицательные, вывести их произведение;<br>* если а и b разных знаков, вывести их сумму;<br>ноль можно считать положительным числом.
		</p>
		<h3>Решение:</h3>
		<p>Введите переменную a:</p>
		<input type="text" id="zd3PerA">
		<p>Введите переменную b:</p>
		<input type="text" id=zd3PerB>
		<div class="button" id=zd3Prov>Проверка</div>
		<div class="zd3Otvet"></div>
	</div>
	<!-- Задание 4 -->
	<div class="zd">
		<h3>Задание 4</h3>
		<p>Присвоить переменной <b>"а"</b> значение в промежутке [0..15]. С помощью оператора switch организовать вывод чисел от a до 15.
		</p>
		<p>Введите число от 0 до 15:</p>
		<input type="text" id="zd4PerA">
		<div class="button" id="zd4Prov">Вывод</div>
		<div class="zd4Otvet"></div>
	</div>
	<!-- Задание 5 -->
	<div class="zd">
		<h3>Задание 5</h3>
		<p>Реализовать основные 4 арифметические операции в виде функций с двумя параметрами. Обязательно использовать оператор return.</p>

		<p>Введите переменную а: </p>
		<input type="text" id=zd5PerA>
		<p>Введите переменную b: </p>
		<input type="text" id=zd5PerB>
		<div class="button" id="zd5Prov">Расчет</div>

		<p>1) Функция сложения:</p>
		<div class="sl"></div>
		<p>2) Функция вычитания: </p>
		<div class="vch"></div>
		<p>3) Функция умножения: </p>
		<div class="um"></div>
		<p>4) Функция деления: </p>
		<div class="del"></div>
	</div>
	<!-- Задание 6 -->
	<div class="zd">
		<h3>Задание 6</h3>
		<p>Реализовать функцию с тремя параметрами: function mathOperation(arg1, arg2, operation), где arg1, arg2 – значения аргументов, operation – строка с названием операции. В зависимости от переданного значения операции выполнить одну из арифметических операций (использовать функции из пункта 3) и вернуть полученное значение (использовать switch).</p>

		<p>Введите первый аргумент: </p>
		<input type="text" id="zd6PerA">
		<p>Введите второйй аргумент: </p>
		<input type="text" id="zd6PerB">
		<p>Что необходимо сделать?</p>
		<select name="oper" id="oper">
			<option value="sl">Сложение</option>
			<option value="vsht">Вычитание</option>
			<option value="umnozh">Умножение</option>
			<option value="delen">Деление</option>
		</select>
		<div class="button" id="zd6Prov">Расчет</div>
		<div class="otvet"></div>
	</div>
	<!-- Задание 7 -->
	<div class="zd">
		<h3>Задание 7</h3>
		<p>
			Сравнить null и 0. Попробуйте объяснить результат.
		</p>
		<p> null > 0; // false </p>
		<div class="button" id="zd7Prov">Проверить</div>
		<div class="otvet1zd7">
			<p>
				<b>Рассмотрим первое сравнение:</b> <br>

null > 0; // false <br>

В соответствии со спецификацией, операторы сравнения > и <, для того, чтобы выяснить, истинно или ложно выражение, пропускают его через так называемый абстрактный алгоритм сравнения для отношений. Здесь и далее мы будем цитировать фрагменты спецификации по тексту перевода «Стандарт ECMA-262, 3я редакция» с ресурса javascript.ru: <br>

Сравнение x < y, где x и y являются значениями, возвращает true, false или undefined (последнее означает, что хотя бы один из операндов равен NaN). Такое сравнение производится следующим образом: <br>
1. Вызвать ToPrimitive(x, подсказка Number). <br>
2. Вызвать ToPrimitive(y, подсказка Number). <br>
3. Если Тип(Результата(1)) равен String и Тип(Результата(2)) равен String - переход на шаг 16. (Заметим, что этот шаг отличается от шага 7 в алгоритме для оператора сложения + тем, что в нём используется и вместо или.) <br>
4. Вызвать ToNumber(Результат(1)). <br>
5. Вызвать ToNumber(Результат(2)). <br>
6. Если Результат(4) равен NaN - вернуть undefined. <br>
7. Если Результат(5) равен NaN - вернуть undefined. <br>
8. Если Результат(4) и Результат(5) являются одинаковыми числовыми значениями - вернуть false. <br>
9. Если Результат(4) равен +0 и Результат(5) равен -0 - вернуть false. <br>
10. Если Результат(4) равен -0 и Результат(5) равен +0 - вернуть false. <br>
11. Если Результат(4) равен +∞, вернуть false. <br>
12. Если Результат(5) равен +∞, вернуть true. <br>
13. Если Результат(5) равен -∞, вернуть false. <br>
14. Если Результат(4) равен -∞, вернуть true. <br>
15. Если математическое значение Результата (4) меньше, чем математическое значение Результата(5) (заметим, что эти математические значения оба конечны и не равны нулю) - вернуть true. Иначе вернуть false. <br>
16. Если Результат(2) является префиксом Результата(1), вернуть false. (Строковое значение p является префиксом строкового значения q, если q может быть результатом конкатенации p и некоторой другой строки r. Отметим, что каждая строка является своим префиксом, т.к. r может быть пустой строкой.) <br>
17. Если Результат(1) является префиксом Результата(2), вернуть true. <br>
18. Пусть k - наименьшее неотрицательное число такое, что символ на позиции k Результата(1) отличается от символа на позиции k Результата(2). (Такое k должно существовать, т.к. на данном шаге установлено, что ни одна из строк не является префиксом другой.) <br>
19. Пусть m - целое, равное юникодному коду символа на позиции k строки Результат(1). <br>
20. Пусть n - целое, равное юникодному коду символа на позиции k строки Результат(2). <br>
21. Если m < n, вернуть true. Иначе вернуть false. <br>

Пройдёмся по этому алгоритму с нашим выражением null > 0. <br>

Шаги 1 и 2 предлагают нам вызвать оператор ToPrimitive() для значений null и 0 для того, чтобы привести эти значения к их элементарному типу (к такому, например, как Number или String). Вот как ToPrimitive преобразует различные значения: <br>
Входной тип: Результат <br>
Undefined: Преобразование не производится <br>
Null: Преобразование не производится <br>
Boolean: Преобразование не производится <br>
Number: Преобразование не производится <br>
String: Преобразование не производится <br>

Возвращает значение по умолчанию для объекта. Значение по умолчанию для объекта получается путём вызова для объекта внутреннего метода [[DefaultValue]] с передачей ему опциональной подсказки ПредпочтительныйТип. <br>

В соответствии с таблицей, ни к левой части выражения, null, ни к правой части, 0, никаких преобразований не применяется. <br>

Шаг 3 алгоритма в нашем случае неприменим, пропускаем его и идём дальше. На шагах 4 и 5 нам нужно преобразовать левую и правую части выражения к типу Number. Преобразование к типу Number выполняется в соответствии со следующей таблицей (здесь опущены правила преобразования для входных типов String и Object, так как они к теме нашего разговора отношения не имеют): <br>
Входной тип: Результат <br>
Undefined: NaN <br>
Null: +0 <br>
Boolean: Результат равен 1, если аргумент равен true. Результат равен +0, если аргумент равен false. <br>
Number: Преобразование не производится <br>
…
…

В соответствии с таблицей, null будет преобразовано в +0, а 0 останется самим собой. Ни одно из этих значений не является NaN, поэтому шаги алгоритма 6 и 7 можно пропустить. А вот на шаге 8 нам надо остановиться. Значение +0 равно 0, в результате алгоритм возвращает false. Таким образом: <br>

null > 0; // false <br>
null < 0; // тоже false <br>

</p>

<p><b>Рассмотрим теперь проверку на равенство null и 0:</b></p>
<p>null == 0; //false</p>

<div class="button" id="zd7Prov2">Проверить</div>

<p>Оператор == использует так называемый абстрактный алгоритм сравнения для равенств, возвращая в результате true или false. Вот этот алгоритм: <br>

Сравнение x == y, где x и y являются значениями, возвращает true или false. Такое сравнение производится следующим образом: <br>
1. Если Тип(x) отличается от Типа(y) - переход на шаг 14. <br>
2. Если Тип(x) равен Undefined - вернуть true. <br>
3. Если Тип(x) равен Null - вернуть true. <br>
4. Если Тип(x) не равен Number - переход на шаг 11. <br>
5. Если x является NaN - вернуть false. <br>
6. Если y является NaN - вернуть false. <br>
7. Если x является таким же числовым значением, что и y, - вернуть true. <br>
8. Если x равен +0, а y равен -0, вернуть true. <br>
9. Если x равен -0, а y равен +0, вернуть true. <br>
10. Вернуть false. <br>
11. Если Тип(x) равен S tring - вернуть true, если x и y являются в точности одинаковыми последовательностями символов (имеют одинаковую длину и одинаковые символы в соответствующих позициях). Иначе вернуть false. <br>
12. Если Тип(x) равен Boolean, вернуть true, если x и y оба равны true или оба равны false. Иначе вернуть false. <br>
13. Вернуть true, если x и y ссылаются на один и тот же объект или они ссылаются на объекты, которые были объединены вместе (см. раздел 13.1.2). Иначе вернуть false. <br>
14. Если x равно null, а y равно undefined - вернуть true. <br>
15. Если x равно undefined, а y равно null - вернуть true. <br>
16. Если Тип(x) равен Number, а Тип(y) равен String, вернуть результат сравнения x == ToNumber(y). <br>
17. Если Тип(x) равен String, а Тип(y) равен Number, вернуть результат сравнения ToNumber(x)== y. <br>
18. Если Тип(x) равен Boolean, вернуть результат сравнения ToNumber(x)== y. <br>
19. Если Тип(y) равен Boolean, вернуть результат сравнения x == ToNumber(y). <br>
20. Если Тип(x) - String или Number, а Тип(y) - Object, вернуть результат сравнения x == ToPrimitive(y). <br>
21. Если Тип(x) - Object, а Тип(y) - String или Number, вернуть результат сравнения ToPrimitive(x)== y. <br>
22. Вернуть false. <br>

Пытаясь понять, равно ли значение null значению 0, мы сразу переходим из шага 1 к шагу 14, так как Тип(x) отличается от Типа(y). Как ни странно, но шаги 14-21 тоже к нашему случаю не подходят, так как Тип(х) — это null. <br>
Наконец мы попадаем на шаг 22, после чего false возвращается как значение по умолчанию! <br>
В результате и оказывается, что: <br>

null == 0; //false
</p>

<p>
	<b>null >= 0; // true</b>
</p>

<div class="button" id="zd7Prov3">Проверить</div>

<p>
	Если null < 0 принимает значение false, то null >= 0 принимает значение true
</p>
<p>
	В результате мы и получаем: <br>

	null >= 0; // true <br>

	И, на самом деле, в этом есть смысл. С точки зрения математики, если у нас есть два числа, x и y, и если x не меньше, чем y, тогда x должно быть больше чем y или равно ему. <br>

	Я предполагаю, что данный оператор работает именно так для того, чтобы оптимизировать вычисления. Зачем сначала проверять, больше ли x чем y, и, если это не так, проверять, равняется ли значение x значению y, если можно выполнить всего одно сравнение, проверить, меньше ли x чем y, а затем использовать результат этого сравнения 	для того, чтобы вывести результат исходного выражения. <br>
</p>


		</div>
	</div>
	<!-- Задание 8 -->
	<div class="zd">
		<h3>Задание 8</h3>
		<p>С помощью рекурсии организовать функцию возведения числа в степень. Формат: function power(val, pow), где val – заданное число, pow – степень.</p>

		<p>Введите число которое хотите возвести в сетепень: </p>
		<input type="text" id="zd8PerA">
		<p>Введите степень: </p>
		<input type="text" id="zd8PerB">
		<div class="button" id="zd8Prov">Расчет</div>
		<div class="rez"></div>
	</div>

		<script src="js/script.js"></script>
</body>
</html>